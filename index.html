<html>
  <head>
    <style>
      html, body { 
        background-color:#000;
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden !important;  
      }
    </style>
    
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
 
    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@latest/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@latest/examples/jsm/"
      }
    }
    </script>
 
    <script type="module">
 
      import * as THREE from 'three';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';      
      //import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';
      import { AnaglyphEffect } from 'three/addons/effects/AnaglyphEffect.js';
      import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
      import { VertexNormalsHelper } from 'three/addons/helpers/VertexNormalsHelper.js';

      import {Pane} from 'https://cdn.jsdelivr.net/npm/tweakpane@4.0.5/dist/tweakpane.min.js';

      import { createCity } from './src/city.js';
      import { createRain } from './src/storm.js';

      var renderer, controls, scene, camera, effect;
      var rain, rainGeo, rainMaterial, rainCount = 15000;
      window['CONTROLS'] = {
      raycaster: new THREE.Raycaster(),
      mouse: new THREE.Vector2(),
      selectedObject: null,


      }

      window.onload = async function() {
 
 
        // create scene
        scene = new THREE.Scene();
 
        // setup the camera
        var fov = 75;
        var ratio = window.innerWidth / window.innerHeight;
        var zNear = 0.1;
        var zFar = 10000;
        camera = new THREE.PerspectiveCamera( fov, ratio, zNear, zFar );
        camera.position.set(0, 0, 100);
 
        // create renderer and add canvas
        renderer = new THREE.WebGLRenderer({antialias:true});
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );
        
        //.. setup lights
        var ambientLight = new THREE.AmbientLight(0x555555);
        scene.add( ambientLight );
 
        var light = new THREE.DirectionalLight( 0xffeedd);
        light.position.set( 0, 0, 1 );
        scene.add( light );
 
       
        // setup interaction
        controls = new OrbitControls( camera, renderer.domElement );
        effect = new AnaglyphEffect(renderer, window.innerWidth, window.innerHeight);

        //set up environment
        const building = await createCity(scene);
        //const rain = await createRain(scene);

        //check objects
        let allObjects = [];
        let meshes = [];

        building.traverse(obj => {
          allObjects.push(obj);
          if (obj.isMesh) meshes.push(obj);
        });

        //rain creation
        let positions = [];
        let sizes = [];
        rainGeo = new THREE.BufferGeometry();
        for(let i=0;i<rainCount;i++) {
            positions.push(Math.random() * 400 -200);
            positions.push(Math.random() * 500 - 250);
            positions.push(Math.random() * 400 - 200);
            sizes.push(30);
        }
        rainGeo.setAttribute(
            "position",
            new THREE.BufferAttribute(new Float32Array(positions),3)
        );

        rainMaterial = new THREE.PointsMaterial({
            color: 0x000000,//0xaaaaaa for white, 0x000000 for black
            size: 0.5,
            transparent: true
        });
        rain = new THREE.Points(rainGeo,rainMaterial);
        console.log("created the rain");
        console.log(rain);
        scene.add(rain);
        //rain creation end===========================================

        console.log("All objects:", allObjects);
        console.log("Mesh objects:", meshes);
        console.log("Mesh count:", meshes.length);
        
        building.allObjects = allObjects;
        building.meshes = meshes;

        animate();

      };
      
      window.addEventListener("pointerdown", onClick);

      function onClick(e) {
        // get mouse position
        CONTROLS.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        CONTROLS.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        // raycast from camera using current mouse position
        CONTROLS.raycaster.setFromCamera(CONTROLS.mouse, camera);

        var click = CONTROLS.raycaster.intersectObjects(scene.children, true);

        if (click.length > 0) {
        const clickObject = click[0].object;

        console.log("You clicked:", clickObject.name, clickObject);

        setSelectedObject(clickObject);
        }
      };

      //select object group
      function setSelectedObject(obj) {
        if (CONTROLS.selectedObject && CONTROLS.selectedObject.material?.emissive) {
          CONTROLS.selectedObject.material.emissive.set(0x000000);
        }

        CONTROLS.selectedObject = obj;

        if (obj.material?.emissive) {
          obj.material.emissive.set(0x4444ff);
        }
      };

      function animate() {
        requestAnimationFrame( animate );

        // rotate object
        if (CONTROLS.selectedObject) {
          CONTROLS.selectedObject.rotation.y += 0.02;
        }

        //rain
        rainGeo.verticesNeedUpdate = true;
        rain.position.y +=0.222;
        if (rain.position.z > 200) rain.position.z = 0;

        controls.update();
        renderer.render(scene, camera);
      };
    </script>
  </head>
  <body></body>
</html>